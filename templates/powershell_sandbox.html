<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Powershell Terminal Emulator</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html,body { height: 100%; }
    body {
      background-color: #1e1e1e;
      font-family: "Courier New", monospace;
      height: 100vh;
      display: flex;
      overflow: hidden;
    }

    .full {
      width: 100%;
      display: flex;
      flex-direction: column;
      min-width: 500px;
    }

    .right {
      width: 30%;
      background:#2b2b2b;
      color:#eee;
      padding:20px;
      border-left:2px solid #444;
      overflow-y:auto;
    }

    .header, .footer {
      background-color: #2d2d2d;
      color: #ccc;
      padding: 8px 15px;
      font-size: 14px;
      display: flex;
      justify-content: space-between;
      align-items:center;
    }

    #terminal { flex:1; margin:10px; border-radius:5px; box-shadow:0 0 10px rgba(0,0,0,0.5); height: calc(100% - 120px); }
    .controls { display:flex; gap:8px; }
    .control-btn { width:12px; height:12px; border-radius:50%; }
    .close{ background:#ff5f56; } .minimize{ background:#ffbd2e; } .maximize{ background:#27c93f; }

    .status { display:flex; gap:15px; }

    h2 { margin-bottom: 12px; font-size: 18px; color:#fff; }

    .checklist-item { margin-bottom: 15px; font-size: 16px; display:flex; align-items:center; gap:10px; }
    .checkmark { width:20px; height:20px; border:2px solid #888; display:inline-block; border-radius:4px; }
    .checkmark.checked { background:#27c93f; border-color:#27c93f; }
    .task-desc { color:#ddd; }

    .small { font-size:12px; color:#bbb; margin-top:10px; }
  </style>
</head>
<body>
  <div class="full">
    <div class="header">
      <div>PowerShell — 80x24</div>
      <div class="controls">
        <div class="control-btn close"></div>
        <div class="control-btn minimize"></div>
        <div class="control-btn maximize"></div>
      </div>
    </div>

    <div id="terminal"></div>

    <div class="footer">
      <div>PowerShell Emulator v1.0</div>
      <div class="status">
        <span>UTF-8</span>
        <span>PowerShell</span>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>

  <script>
  // --------------------------
  // Terminal init
  // --------------------------
  const term = new Terminal({
    cursorBlink: true,
    fontSize: 14,
    fontFamily: "'Courier New', monospace",
    theme: {
      background: "#1e1e1e",
      foreground: "#f0f0f0",
      cursor: "#ffffff",
      selection: "#555555"
    }
  });

  const fitAddon = new FitAddon.FitAddon();
  term.loadAddon(fitAddon);
  term.open(document.getElementById("terminal"));
  fitAddon.fit();
  window.addEventListener("resize", () => fitAddon.fit());

  // --------------------------
  // State + VFS
  // --------------------------
  let currentLine = "";
  let commandHistory = [];
  let historyIndex = -1;

  let currentLocation = "C:\\Users\\User";
  let previousLocation = currentLocation; // for cd -

  let FS = {
    "C:": {
      "Users": {
        "User": {
          "readme.txt": "Welcome to the simulated PowerShell environment.",
          "notes.txt": "Editable text file.",
          "Folder": {
            "example.txt": "File inside Folder."
          }
        }
      }
    }
  };

  function pathToArray(path) {
    return path.replace(/\\/g, "/").split("/");
  }

  function resolvePath(input) {
    // handle empty or '.'
    if (!input || input === ".") return pathToArray(currentLocation);

    // go up one directory
    if (input === "..") {
      let arr = pathToArray(currentLocation);
      arr.pop();
      return arr;
    }

    // 'cd -' handled separately in command processing (so don't resolve here)
    // absolute path like C:\something
    if (input.match(/^[A-Za-z]:\\/)) {
      return pathToArray(input);
    }

    // relative path
    return pathToArray(currentLocation + "\\" + input);
  }

  function getNode(pathArr) {
    let node = FS;
    for (let part of pathArr) {
      if (!part) continue;
      if (!(part in node)) return null;
      node = node[part];
    }
    return node;
  }

  function isDir(node) {
    return typeof node === "object";
  }

  // --------------------------
  // Prompt
  // --------------------------
  function prompt() {
    term.write(`\r\nPS ${currentLocation}> `);
  }

  term.write("PowerShell Emulator\r\nType 'Get-Help' for assistance.");
  prompt();

  // --------------------------
  // Checklist helpers
  // --------------------------
  function markCheck(id) {
    const el = document.getElementById(id);
    if (el && !el.classList.contains('checked')) el.classList.add('checked');
  }

  // --------------------------
  // Command processing
  // returns boolean success
  // --------------------------
  function processCommand(input) {
    const raw = input.trim();
    if (!raw) return false;
    commandHistory.push(raw);
    historyIndex = commandHistory.length;
    const parts = raw.split(/\s+/);
    const cmd = parts[0].toLowerCase();
    const args = parts.slice(1);

    let success = false; // track whether command succeeded

    switch (cmd) {

      case "get-help":
      case "help":
        term.write("\r\nAvailable PowerShell Commands:");
        term.write("\r\n  Get-ChildItem (ls)");
        term.write("\r\n  Set-Location (cd)");
        term.write("\r\n  Get-Content");
        term.write("\r\n  Set-Content");
        term.write("\r\n  Add-Content");
        term.write("\r\n  New-Item");
        term.write("\r\n  Remove-Item");
        term.write("\r\n  Copy-Item");
        term.write("\r\n  Move-Item");
        term.write("\r\n  Get-Command");
        term.write("\r\n  Get-Alias");
        success = true;
        break;

      case "get-command":
        term.write("\r\nSimulated Commands:");
        term.write("\r\nGet-ChildItem, Set-Location, Get-Content, Set-Content");
        term.write("\r\nAdd-Content, New-Item, Remove-Item, Copy-Item, Move-Item");
        success = true;
        break;

      case "get-alias":
        term.write("\r\nAliases:");
        term.write("\r\nls -> Get-ChildItem");
        term.write("\r\ncd -> Set-Location");
        term.write("\r\ncat, gc -> Get-Content");
        term.write("\r\ncp -> Copy-Item");
        term.write("\nrm -> Remove-Item");
        success = true;
        break;

      case "ls":
      case "gci":
      case "get-childitem": {
        const node = getNode(pathToArray(currentLocation));
        if (!node || !isDir(node)) {
          term.write("\r\nError: Directory not found.");
          success = false;
          break;
        }
        term.write("\r\n" + Object.keys(node).join("    "));
        success = true;
        break;
      }

      case "cd":
      case "sl":
      case "set-location": {
        const target = args[0] || "";
        // handle 'cd -'
        if (target === "-") {
          // swap
          const tmp = currentLocation;
          currentLocation = previousLocation;
          previousLocation = tmp;
          success = true;
          break;
        }

        const resolved = resolvePath(target);
        const node = getNode(resolved);

        if (!node || !isDir(node)) {
          term.write(`\r\nSet-Location : Cannot find path '${target}'`);
          success = false;
          break;
        }

        previousLocation = currentLocation;
        currentLocation = resolved.join("\\");
        success = true;
        break;
      }

      case "gc":
      case "cat":
      case "get-content": {
        if (!args[0]) {
          term.write("\r\nUsage: Get-Content <file>");
          success = false;
          break;
        }
        const p = resolvePath(args[0]);
        const node = getNode(p);
        if (!node || typeof node !== "string") {
          term.write("\r\nGet-Content : File not found.");
          success = false;
          break;
        }
        term.write("\r\n" + node);
        success = true;
        break;
      }

      case "set-content": {
        if (args.length < 2) {
          term.write("\r\nUsage: Set-Content <file> <text>");
          success = false;
          break;
        }
        const p = resolvePath(args[0]);
        const parent = getNode(p.slice(0, -1));
        if (!parent || !isDir(parent)) {
          term.write("\r\nSet-Content : Path not found.");
          success = false;
          break;
        }
        parent[p.at(-1)] = args.slice(1).join(" ");
        term.write("\r\nContent written.");
        success = true;
        break;
      }

      case "add-content": {
        if (args.length < 2) {
          term.write("\r\nUsage: Add-Content <file> <text>");
          success = false;
          break;
        }
        const p = resolvePath(args[0]);
        const parent = getNode(p.slice(0, -1));
        if (!parent || !isDir(parent)) {
          term.write("\r\nAdd-Content : Path not found.");
          success = false;
          break;
        }
        const name = p.at(-1);
        if (typeof parent[name] !== "string")
          parent[name] = "";
        parent[name] += (parent[name] ? "\n" : "") + args.slice(1).join(" ");
        term.write("\r\nContent appended.");
        success = true;
        break;
      }

      case "ni":
      case "new-item": {
        if (!args[0]) {
          term.write("\r\nUsage: New-Item <filename>");
          success = false;
          break;
        }
        const p = resolvePath(args[0]);
        const parent = getNode(p.slice(0, -1));
        if (!parent || !isDir(parent)) {
          term.write("\r\nNew-Item : Path not found.");
          success = false;
          break;
        }
        parent[p.at(-1)] = "";
        term.write("\r\nNew file created.");
        success = true;
        break;
      }

      case "rm":
      case "ri":
      case "remove-item": {
        if (!args[0]) {
          term.write("\r\nUsage: Remove-Item <path>");
          success = false;
          break;
        }
        const p = resolvePath(args[0]);
        const parent = getNode(p.slice(0, -1));
        if (!parent || !(p.at(-1) in parent)) {
          term.write("\r\nRemove-Item : Item not found.");
          success = false;
          break;
        }
        delete parent[p.at(-1)];
        term.write("\r\nItem removed.");
        success = true;
        break;
      }

      case "copy-item":
      case "cp": {
        if (args.length < 2) {
          term.write("\r\nUsage: Copy-Item <src> <dest>");
          success = false;
          break;
        }

        const sourceNode = getNode(resolvePath(args[0]));
        if (!sourceNode) {
          term.write("\r\nSource not found.");
          success = false;
          break;
        }

        const dest = resolvePath(args[1]);
        const destParent = getNode(dest.slice(0, -1));
        if (!destParent || !isDir(destParent)) {
          term.write("\r\nDestination path not found.");
          success = false;
          break;
        }
        // structuredClone fallback if not available
        const clone = (typeof structuredClone === 'function') ? structuredClone(sourceNode) : JSON.parse(JSON.stringify(sourceNode));
        destParent[dest.at(-1)] = clone;

        term.write("\r\nCopied.");
        success = true;
        break;
      }

      case "move-item":
      case "mv": {
        if (args.length < 2) {
          term.write("\r\nUsage: Move-Item <src> <dest>");
          success = false;
          break;
        }

        const srcP = resolvePath(args[0]);
        const srcParent = getNode(srcP.slice(0, -1));
        const srcNode = getNode(srcP);

        if (!srcNode || !srcParent) {
          term.write("\r\nSource not found.");
          success = false;
          break;
        }

        const destP = resolvePath(args[1]);
        const destParent = getNode(destP.slice(0, -1));
        if (!destParent || !isDir(destParent)) {
          term.write("\r\nDestination path not found.");
          success = false;
          break;
        }

        destParent[destP.at(-1)] = srcNode;
        delete srcParent[srcP.at(-1)];

        term.write("\r\nMoved.");
        success = true;
        break;
      }

      default:
        term.write(`\r\n${raw} : The term '${raw}' is not recognized as a PowerShell command.`);
        success = false;
        break;
    }

    // After command executed, mark checklist items only if success true:
    if (success) {
      // list files
      if (["ls","gci","get-childitem"].includes(cmd)) markCheck('check-list');

      // system info (help / get-command / get-alias)
      if (["get-help","help","get-command","get-alias"].includes(cmd)) markCheck('check-info');

      // set-location variants
      if (["cd","sl","set-location"].includes(cmd)) {
        markCheck('check-location');
        // cd - specifically checks navigation
        if (args[0] === "-" || (cmd === "cd" && args[0] === "-")) {
          markCheck('check-navigation');
        }
      }

      // read/write files
      if (["gc","cat","get-content","set-content","add-content"].includes(cmd)) markCheck('check-readwrite');

      // manipulate files (new, remove, copy, move)
      if (["ni","new-item","rm","ri","remove-item","copy-item","cp","move-item","mv"].includes(cmd)) markCheck('check-manipulate');

      // cd - might be entered as command only
      if (cmd === "cd" && args[0] === "-") markCheck('check-navigation');
    }

    return success;
  }

  // --------------------------
  // Terminal input handling
  // --------------------------
  term.onData(data => {
    const code = data.charCodeAt(0);

    if (code === 13) { // Enter
      processCommand(currentLine);
      currentLine = "";
      prompt();
    }
    else if (code === 127) { // Backspace
      if (currentLine.length > 0) {
        currentLine = currentLine.slice(0, -1);
        term.write("\b \b");
      }
    }
    else if (code === 27 && data.length > 1 && data[1] === "[") {
      // arrow keys
      if (data[2] === "A") { // ↑
        if (historyIndex > 0) {
          historyIndex--;
          clearLine();
          currentLine = commandHistory[historyIndex];
          term.write(currentLine);
        }
      }
      else if (data[2] === "B") { // ↓
        if (historyIndex < commandHistory.length - 1) {
          historyIndex++;
          clearLine();
          currentLine = commandHistory[historyIndex];
          term.write(currentLine);
        } else {
          clearLine();
          currentLine = "";
        }
      }
    }
    else if (code >= 32 && code <= 126) {
      currentLine += data;
      term.write(data);
    }
  });

  function clearLine() {
    // erase to end of line and reprint prompt prefix
    term.write("\r\x1b[KPS " + currentLocation + "> ");
  }

  term.focus();
  </script>
</body>
</html>

