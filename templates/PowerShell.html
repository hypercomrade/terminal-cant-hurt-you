<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>ZSH Terminal Emulator</title>
        <link
            rel="stylesheet"
            href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css"
        />
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                background-color: #000000;
                font-family: "Segoe UI", monospace;
                height: 100vh;
                display: flex;
                flex-direction: column;
                overflow: hidden;
            }

            .terminal-container {
                flex: 1;
                padding: 10px;
                display: flex;
                flex-direction: column;
            }

            #terminal {
                width: 100%;
                height: 100%;
                border-radius: 0px;
                background-color:#ccc;
                overflow: hidden;
              }

            .header {
                background-color: #ccc;
                color: #000000;
                padding: 10px 10px;
                font-size: 14px;
                display: flex;
                justify-content: space-between;
                border-top-left-radius: 5px;
                border-top-right-radius: 5px;
            }

            .controls {
                display: flex;
                gap: 8px;
            }

            .control-btn {
                width: 12px;
                height: 12px;
                border-radius: 50%;
            }

            .footer {
                background-color: #ccc;
                color: #ccc;
                padding: 5px 15px;
                font-size: 12px;
                border-bottom-left-radius: 5px;
                border-bottom-right-radius: 5px;
                display: flex;
                justify-content: space-between;
            }

            .status {
                display: flex;
                gap: 15px;
            }
        </style>
    </head>
    <body>
        <div class="terminal-container">
            <div class="header">
                <div>Windows PowerShell</div>
                <div class="controls">
                    <div class="control-btn close"></div>
                    <div class="control-btn minimize"></div>
                    <div class="control-btn maximize"></div>
                </div>
            </div>
            <div id="terminal"></div>
            <div class="footer">
                <div>ZSH Terminal v1.0</div>
                <div class="status">
                    <span>UTF-8</span>
                    <span>zsh</span>
                </div>
            </div>
        </div>

        <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>
        <script>
            // Initialize terminal
            const term = new Terminal({
                cursorBlink: true,
                fontSize: 14,
                fontFamily: "'Cascadia Mono', monospace",
                theme: {
                    background: "#24245d",
                    foreground: "#f0f0f0",
                    cursor: "#ffffff",
                    selection: "#555555",
                },
            });

            // Add fit addon to make terminal responsive
            const fitAddon = new FitAddon.FitAddon();
            term.loadAddon(fitAddon);

            // Open terminal in container
            term.open(document.getElementById("terminal"));
            fitAddon.fit();

            // Handle window resize
            window.addEventListener("resize", () => {
                fitAddon.fit();
            });

            // Terminal state
            let currentLine = "";
            let commandHistory = [];
            let historyIndex = -1;
            let currentUser = "User";
            let currentHost = "localhost";
            let currentDirectory = ">";

            // ZSH-specific features
            let zshAutocompleteIndex = -1;
            let zshAutocompleteOptions = [];

            // Initial prompt with ZSH style
            function writePrompt() {
                term.write(
                    `\r\n\x1b[97m${"PS C:" }/${currentHost}\x1b\x1b[97m${currentUser}/${currentHost}\x1b[0m \x1b[5m${currentDirectory}\x1b[0m  `,
                );
            }

            // Write welcome message
            term.write("Windows PowerShell");
            term.write('\r\nType "Copyright (C) Microsoft Corpotation. All rights reserved.');
            writePrompt();

            // ZSH-specific commands
            const zshCommands = {
                "git status": "On branch main\nYour branch is up to date with 'origin/main'.",
                "git log": "commit abc123 (HEAD -> main)\nAuthor: User <user@example.com>\nDate:   Mon Jan 1 12:00:00 2023\n\n    Initial commit",
                "brew install": "Installing package...",
                "npm install": "Installing dependencies...",
                "python3": "Python 3.9.0 (default, Oct  6 2020, 00:00:00)\n[Clang 12.0.0 ] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.",
                "node": "Welcome to Node.js v14.15.0.\nType \".help\" for more information.",
                "autoload": "Function autoloaded successfully.",
                "compinit": "Initializing completion...",
                "zsh-theme": "Switching to theme: robbyrussell",
            };

            // Process commands
            function processCommand(command) {
                const cmd = command.trim();

                if (cmd === "") {
                    return;
                }

                // Add to command history
                commandHistory.push(cmd);
                historyIndex = commandHistory.length;

                // Parse command and arguments
                const parts = cmd.split(" ");
                const baseCmd = parts[0].toLowerCase();
                const args = parts.slice(1);

                // Check for ZSH-specific commands first
                if (zshCommands[cmd]) {
                    term.write(`\r\n${zshCommands[cmd]}`);
                    writePrompt();
                    return;
                }

                switch (baseCmd) {
                    case "help":
                        term.write("\r\nAvailable commands:");
                        term.write("\r\n  help     - Show this help message");
                        term.write("\r\n  clear    - Clear the terminal");
                        term.write("\r\n  ls       - List directory contents");
                        term.write("\r\n  pwd      - Print working directory");
                        term.write("\r\n  cd       - Change directory");
                        term.write("\r\n  echo     - Display a line of text");
                        term.write("\r\n  whoami   - Print current user");
                        term.write(
                            "\r\n  date     - Display current date and time",
                        );
                        term.write("\r\n  git      - Git commands (status, log)");
                        term.write("\r\n  brew     - Package manager");
                        term.write("\r\n  npm      - Node package manager");
                        term.write("\r\n  python3  - Python interpreter");
                        term.write("\r\n  node     - Node.js interpreter");
                        term.write("\r\n  autoload - ZSH autoload function");
                        term.write("\r\n  compinit - ZSH completion init");
                        term.write("\r\n  zsh-theme- Change ZSH theme");
                        term.write("\r\n  exit     - Exit the terminal");
                        break;

                    case "clear":
                        term.clear();
                        break;

                    case "ls":
                        term.write(
                            "\r\nApplications  Documents  Downloads  Library  Movies  Music  Pictures  Public",
                        );
                        break;

                    case "pwd":
                        term.write(`\r\n${currentDirectory}`);
                        break;

                    case "cd":
                        if (args.length === 0 || args[0] === "~") {
                            currentDirectory = "~";
                        } else if (args[0] === "..") {
                            if (currentDirectory !== "~") {
                                const dirs = currentDirectory.split("/");
                                dirs.pop();
                                currentDirectory = dirs.join("/") || "~";
                            }
                        } else {
                            currentDirectory = args[0];
                        }
                        break;

                    case "echo":
                        term.write(`\r\n${args.join(" ")}`);
                        break;

                    case "whoami":
                        term.write(`\r\n${currentUser}`);
                        break;

                    case "date":
                        term.write(`\r\n${new Date().toString()}`);
                        break;

                    case "git":
                        if (args.length > 0) {
                            const gitCmd = `git ${args.join(" ")}`;
                            if (zshCommands[gitCmd]) {
                                term.write(`\r\n${zshCommands[gitCmd]}`);
                            } else {
                                term.write(`\r\nUnknown git command: ${args.join(" ")}`);
                            }
                        } else {
                            term.write("\r\ngit version 2.30.0");
                        }
                        break;

                    case "brew":
                        if (args.length > 0) {
                            const brewCmd = `brew ${args.join(" ")}`;
                            if (zshCommands[brewCmd]) {
                                term.write(`\r\n${zshCommands[brewCmd]}`);
                            } else {
                                term.write(`\r\nUnknown brew command: ${args.join(" ")}`);
                            }
                        } else {
                            term.write("\r\nHomebrew 3.0.0");
                        }
                        break;

                    case "npm":
                        if (args.length > 0) {
                            const npmCmd = `npm ${args.join(" ")}`;
                            if (zshCommands[npmCmd]) {
                                term.write(`\r\n${zshCommands[npmCmd]}`);
                            } else {
                                term.write(`\r\nUnknown npm command: ${args.join(" ")}`);
                            }
                        } else {
                            term.write("\r\nnpm version 7.0.0");
                        }
                        break;

                    case "python3":
                        term.write("\r\nPython 3.9.0 (default, Oct  6 2020, 00:00:00)");
                        term.write("\r\n[Clang 12.0.0 ] on darwin");
                        term.write("\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.");
                        term.write("\r\n>>> ");
                        break;

                    case "node":
                        term.write("\r\nWelcome to Node.js v14.15.0.");
                        term.write('\r\nType ".help" for more information.');
                        term.write("\r\n> ");
                        break;

                    case "autoload":
                        term.write("\r\nFunction autoloaded successfully.");
                        break;

                    case "compinit":
                        term.write("\r\nInitializing completion...");
                        break;

                    case "zsh-theme":
                        if (args.length > 0) {
                            term.write(`\r\nSwitching to theme: ${args[0]}`);
                        } else {
                            term.write("\r\nCurrent theme: robbyrussell");
                        }
                        break;

                    case "exit":
                        term.write("\r\nGoodbye!");
                        setTimeout(() => {
                            term.write("\r\n\r\n[Process completed]");
                        }, 500);
                        break;

                    default:
                        term.write(`\r\n\x1b[48;2;0;0;0m\x1b[31mPS C: The term ${baseCmd} is not recognized as the name of a cmdlet, function, script file, or operable program. Check the spelling of the name, or if a path was included, verify that the path is correct and try again.\x1b[0m`);

                        break;
                }
                
                if (baseCmd !== "clear" && baseCmd !== "exit") {
                    writePrompt();
                }
            }

            // Handle terminal input
            term.onData((data) => {
                const code = data.charCodeAt(0);

                // Handle special keys
                if (code === 13) {
                    // Enter key
                    processCommand(currentLine);
                    currentLine = "";
                } else if (code === 127) {
                    // Backspace key
                    if (currentLine.length > 0) {
                        currentLine = currentLine.slice(0, -1);
                        term.write("\b \b");
                    }
                } else if (code === 9) {
                    // Tab key for autocomplete
                    const suggestions = Object.keys(zshCommands).filter(cmd => 
                        cmd.startsWith(currentLine)
                    );
                    
                    if (suggestions.length > 0) {
                        if (zshAutocompleteIndex === -1) {
                            zshAutocompleteOptions = suggestions;
                            zshAutocompleteIndex = 0;
                        } else {
                            zshAutocompleteIndex = (zshAutocompleteIndex + 1) % zshAutocompleteOptions.length;
                        }
                        
                        // Clear current line
                        term.write("\r\x1b[K");
                        currentLine = zshAutocompleteOptions[zshAutocompleteIndex];
                        term.write(currentLine);
                    }
                } else if (code === 27) {
                    // Escape sequences (arrows, etc.)
                    // Handle arrow keys for command history
                    if (data.length > 1 && data[1] === "[") {
                        zshAutocompleteIndex = -1; // Reset autocomplete on arrow keys
                        
                        switch (data[2]) {
                            case "A": // Up arrow
                                if (historyIndex > 0) {
                                    historyIndex--;
                                    // Clear current line
                                    term.write("\r\x1b[K");
                                    currentLine = commandHistory[historyIndex];
                                    term.write(currentLine);
                                }
                                break;
                            case "B": // Down arrow
                                if (historyIndex < commandHistory.length - 1) {
                                    historyIndex++;
                                    // Clear current line
                                    term.write("\r\x1b[K");
                                    currentLine = commandHistory[historyIndex];
                                    term.write(currentLine);
                                } else if (
                                    historyIndex ===
                                    commandHistory.length - 1
                                ) {
                                    historyIndex = commandHistory.length;
                                    // Clear current line
                                    term.write("\r\x1b[K");
                                    currentLine = "";
                                }
                                break;
                        }
                    }
                } else if (code >= 32 && code <= 126) {
                    // Printable characters
                    zshAutocompleteIndex = -1; // Reset autocomplete on typing
                    currentLine += data;
                    term.write(data);
                }
            });

            // Focus the terminal on load
            term.focus();
        </script>
    </body>
</html>